#!/bin/bash

# global variable: redistributing
	# - when true, new commands should not be sent to workers.
	# - needs to be readable for all threads.
	# - needs to be changeable by all threads.
$redistributing = false

# collect SSH information for each worker from file

# start a thread for each socket to a worker/middle.

# determine which threads are middles, and split threads to middles into threads to individual workers.

# download program folder for each worker.

# make x number of queues (x defined as the number of worker threads.) Since middles can have multiple workers, this number can be larger than the number of sockets open.

# when a socket is closed before the cluster is powered down, compensate.
	# try to reopen connection

	# if unsuccessful, close thread + redistribute

# get each thread busy!
	
	# get the first command on the queue for this thread

	# run the command
	
	# delete the entry in the queue when the command is successfully run.

	# if the command is interrupted by a socket failure, compensate using the defined method. 
	
# when a thread runs out:

	# if the queues are imbalanced, redistribute


*should we implement a data center like you suggested, Leor, instead of just syncing stuff?

	